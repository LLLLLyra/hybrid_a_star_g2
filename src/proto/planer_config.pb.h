// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: planer_config.proto

#ifndef PROTOBUF_INCLUDED_planer_5fconfig_2eproto
#define PROTOBUF_INCLUDED_planer_5fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_planer_5fconfig_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_planer_5fconfig_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[3]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_planer_5fconfig_2eproto();
namespace planing {
class PiecewiseJerkSpeedOptimizerConfig;
class PiecewiseJerkSpeedOptimizerConfigDefaultTypeInternal;
extern PiecewiseJerkSpeedOptimizerConfigDefaultTypeInternal _PiecewiseJerkSpeedOptimizerConfig_default_instance_;
class PlannerOpenSpaceConfig;
class PlannerOpenSpaceConfigDefaultTypeInternal;
extern PlannerOpenSpaceConfigDefaultTypeInternal _PlannerOpenSpaceConfig_default_instance_;
class WarmStartConfig;
class WarmStartConfigDefaultTypeInternal;
extern WarmStartConfigDefaultTypeInternal _WarmStartConfig_default_instance_;
}  // namespace planing
namespace google {
namespace protobuf {
template<> ::planing::PiecewiseJerkSpeedOptimizerConfig* Arena::CreateMaybeMessage<::planing::PiecewiseJerkSpeedOptimizerConfig>(Arena*);
template<> ::planing::PlannerOpenSpaceConfig* Arena::CreateMaybeMessage<::planing::PlannerOpenSpaceConfig>(Arena*);
template<> ::planing::WarmStartConfig* Arena::CreateMaybeMessage<::planing::WarmStartConfig>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace planing {

// ===================================================================

class PlannerOpenSpaceConfig :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planing.PlannerOpenSpaceConfig) */ {
 public:
  PlannerOpenSpaceConfig();
  virtual ~PlannerOpenSpaceConfig();

  PlannerOpenSpaceConfig(const PlannerOpenSpaceConfig& from);

  inline PlannerOpenSpaceConfig& operator=(const PlannerOpenSpaceConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlannerOpenSpaceConfig(PlannerOpenSpaceConfig&& from) noexcept
    : PlannerOpenSpaceConfig() {
    *this = ::std::move(from);
  }

  inline PlannerOpenSpaceConfig& operator=(PlannerOpenSpaceConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PlannerOpenSpaceConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlannerOpenSpaceConfig* internal_default_instance() {
    return reinterpret_cast<const PlannerOpenSpaceConfig*>(
               &_PlannerOpenSpaceConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(PlannerOpenSpaceConfig* other);
  friend void swap(PlannerOpenSpaceConfig& a, PlannerOpenSpaceConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlannerOpenSpaceConfig* New() const final {
    return CreateMaybeMessage<PlannerOpenSpaceConfig>(nullptr);
  }

  PlannerOpenSpaceConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlannerOpenSpaceConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlannerOpenSpaceConfig& from);
  void MergeFrom(const PlannerOpenSpaceConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlannerOpenSpaceConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .planing.WarmStartConfig warm_start_config = 2;
  bool has_warm_start_config() const;
  void clear_warm_start_config();
  static const int kWarmStartConfigFieldNumber = 2;
  const ::planing::WarmStartConfig& warm_start_config() const;
  ::planing::WarmStartConfig* release_warm_start_config();
  ::planing::WarmStartConfig* mutable_warm_start_config();
  void set_allocated_warm_start_config(::planing::WarmStartConfig* warm_start_config);

  // optional bool enable_check_parallel_trajectory = 9 [default = false];
  bool has_enable_check_parallel_trajectory() const;
  void clear_enable_check_parallel_trajectory();
  static const int kEnableCheckParallelTrajectoryFieldNumber = 9;
  bool enable_check_parallel_trajectory() const;
  void set_enable_check_parallel_trajectory(bool value);

  // optional bool enable_linear_interpolation = 10 [default = false];
  bool has_enable_linear_interpolation() const;
  void clear_enable_linear_interpolation();
  static const int kEnableLinearInterpolationFieldNumber = 10;
  bool enable_linear_interpolation() const;
  void set_enable_linear_interpolation(bool value);

  // optional float delta_t = 7 [default = 1];
  bool has_delta_t() const;
  void clear_delta_t();
  static const int kDeltaTFieldNumber = 7;
  float delta_t() const;
  void set_delta_t(float value);

  // optional double is_near_destination_threshold = 8 [default = 0.001];
  bool has_is_near_destination_threshold() const;
  void clear_is_near_destination_threshold();
  static const int kIsNearDestinationThresholdFieldNumber = 8;
  double is_near_destination_threshold() const;
  void set_is_near_destination_threshold(double value);

  // optional double is_near_destination_theta_threshold = 11 [default = 0.05];
  bool has_is_near_destination_theta_threshold() const;
  void clear_is_near_destination_theta_threshold();
  static const int kIsNearDestinationThetaThresholdFieldNumber = 11;
  double is_near_destination_theta_threshold() const;
  void set_is_near_destination_theta_threshold(double value);

  // @@protoc_insertion_point(class_scope:planing.PlannerOpenSpaceConfig)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::planing::WarmStartConfig* warm_start_config_;
  bool enable_check_parallel_trajectory_;
  bool enable_linear_interpolation_;
  float delta_t_;
  double is_near_destination_threshold_;
  double is_near_destination_theta_threshold_;
  friend struct ::TableStruct_planer_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class WarmStartConfig :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planing.WarmStartConfig) */ {
 public:
  WarmStartConfig();
  virtual ~WarmStartConfig();

  WarmStartConfig(const WarmStartConfig& from);

  inline WarmStartConfig& operator=(const WarmStartConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WarmStartConfig(WarmStartConfig&& from) noexcept
    : WarmStartConfig() {
    *this = ::std::move(from);
  }

  inline WarmStartConfig& operator=(WarmStartConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WarmStartConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WarmStartConfig* internal_default_instance() {
    return reinterpret_cast<const WarmStartConfig*>(
               &_WarmStartConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(WarmStartConfig* other);
  friend void swap(WarmStartConfig& a, WarmStartConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WarmStartConfig* New() const final {
    return CreateMaybeMessage<WarmStartConfig>(nullptr);
  }

  WarmStartConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WarmStartConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WarmStartConfig& from);
  void MergeFrom(const WarmStartConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WarmStartConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .planing.PiecewiseJerkSpeedOptimizerConfig s_curve_config = 17;
  bool has_s_curve_config() const;
  void clear_s_curve_config();
  static const int kSCurveConfigFieldNumber = 17;
  const ::planing::PiecewiseJerkSpeedOptimizerConfig& s_curve_config() const;
  ::planing::PiecewiseJerkSpeedOptimizerConfig* release_s_curve_config();
  ::planing::PiecewiseJerkSpeedOptimizerConfig* mutable_s_curve_config();
  void set_allocated_s_curve_config(::planing::PiecewiseJerkSpeedOptimizerConfig* s_curve_config);

  // optional double traj_forward_penalty = 5 [default = 0];
  bool has_traj_forward_penalty() const;
  void clear_traj_forward_penalty();
  static const int kTrajForwardPenaltyFieldNumber = 5;
  double traj_forward_penalty() const;
  void set_traj_forward_penalty(double value);

  // optional double traj_back_penalty = 6 [default = 0];
  bool has_traj_back_penalty() const;
  void clear_traj_back_penalty();
  static const int kTrajBackPenaltyFieldNumber = 6;
  double traj_back_penalty() const;
  void set_traj_back_penalty(double value);

  // optional double traj_gear_switch_penalty = 7 [default = 0];
  bool has_traj_gear_switch_penalty() const;
  void clear_traj_gear_switch_penalty();
  static const int kTrajGearSwitchPenaltyFieldNumber = 7;
  double traj_gear_switch_penalty() const;
  void set_traj_gear_switch_penalty(double value);

  // optional double xy_grid_resolution = 1 [default = 0.1];
  bool has_xy_grid_resolution() const;
  void clear_xy_grid_resolution();
  static const int kXyGridResolutionFieldNumber = 1;
  double xy_grid_resolution() const;
  void set_xy_grid_resolution(double value);

  // optional double phi_grid_resolution = 2 [default = 0.005];
  bool has_phi_grid_resolution() const;
  void clear_phi_grid_resolution();
  static const int kPhiGridResolutionFieldNumber = 2;
  double phi_grid_resolution() const;
  void set_phi_grid_resolution(double value);

  // optional uint64 next_node_num = 3 [default = 10];
  bool has_next_node_num() const;
  void clear_next_node_num();
  static const int kNextNodeNumFieldNumber = 3;
  ::google::protobuf::uint64 next_node_num() const;
  void set_next_node_num(::google::protobuf::uint64 value);

  // optional double step_size = 4 [default = 0.05];
  bool has_step_size() const;
  void clear_step_size();
  static const int kStepSizeFieldNumber = 4;
  double step_size() const;
  void set_step_size(double value);

  // optional double traj_steer_penalty = 8 [default = 50];
  bool has_traj_steer_penalty() const;
  void clear_traj_steer_penalty();
  static const int kTrajSteerPenaltyFieldNumber = 8;
  double traj_steer_penalty() const;
  void set_traj_steer_penalty(double value);

  // optional double traj_steer_change_penalty = 9 [default = 25];
  bool has_traj_steer_change_penalty() const;
  void clear_traj_steer_change_penalty();
  static const int kTrajSteerChangePenaltyFieldNumber = 9;
  double traj_steer_change_penalty() const;
  void set_traj_steer_change_penalty(double value);

  // optional double grid_a_star_xy_resolution = 15 [default = 0.1];
  bool has_grid_a_star_xy_resolution() const;
  void clear_grid_a_star_xy_resolution();
  static const int kGridAStarXyResolutionFieldNumber = 15;
  double grid_a_star_xy_resolution() const;
  void set_grid_a_star_xy_resolution(double value);

  // optional double node_radius = 16 [default = 0.5];
  bool has_node_radius() const;
  void clear_node_radius();
  static const int kNodeRadiusFieldNumber = 16;
  double node_radius() const;
  void set_node_radius(double value);

  // @@protoc_insertion_point(class_scope:planing.WarmStartConfig)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::planing::PiecewiseJerkSpeedOptimizerConfig* s_curve_config_;
  double traj_forward_penalty_;
  double traj_back_penalty_;
  double traj_gear_switch_penalty_;
  double xy_grid_resolution_;
  double phi_grid_resolution_;
  ::google::protobuf::uint64 next_node_num_;
  double step_size_;
  double traj_steer_penalty_;
  double traj_steer_change_penalty_;
  double grid_a_star_xy_resolution_;
  double node_radius_;
  friend struct ::TableStruct_planer_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class PiecewiseJerkSpeedOptimizerConfig :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planing.PiecewiseJerkSpeedOptimizerConfig) */ {
 public:
  PiecewiseJerkSpeedOptimizerConfig();
  virtual ~PiecewiseJerkSpeedOptimizerConfig();

  PiecewiseJerkSpeedOptimizerConfig(const PiecewiseJerkSpeedOptimizerConfig& from);

  inline PiecewiseJerkSpeedOptimizerConfig& operator=(const PiecewiseJerkSpeedOptimizerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PiecewiseJerkSpeedOptimizerConfig(PiecewiseJerkSpeedOptimizerConfig&& from) noexcept
    : PiecewiseJerkSpeedOptimizerConfig() {
    *this = ::std::move(from);
  }

  inline PiecewiseJerkSpeedOptimizerConfig& operator=(PiecewiseJerkSpeedOptimizerConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PiecewiseJerkSpeedOptimizerConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PiecewiseJerkSpeedOptimizerConfig* internal_default_instance() {
    return reinterpret_cast<const PiecewiseJerkSpeedOptimizerConfig*>(
               &_PiecewiseJerkSpeedOptimizerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(PiecewiseJerkSpeedOptimizerConfig* other);
  friend void swap(PiecewiseJerkSpeedOptimizerConfig& a, PiecewiseJerkSpeedOptimizerConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PiecewiseJerkSpeedOptimizerConfig* New() const final {
    return CreateMaybeMessage<PiecewiseJerkSpeedOptimizerConfig>(nullptr);
  }

  PiecewiseJerkSpeedOptimizerConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PiecewiseJerkSpeedOptimizerConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PiecewiseJerkSpeedOptimizerConfig& from);
  void MergeFrom(const PiecewiseJerkSpeedOptimizerConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PiecewiseJerkSpeedOptimizerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double acc_weight = 1 [default = 1];
  bool has_acc_weight() const;
  void clear_acc_weight();
  static const int kAccWeightFieldNumber = 1;
  double acc_weight() const;
  void set_acc_weight(double value);

  // optional double jerk_weight = 2 [default = 10];
  bool has_jerk_weight() const;
  void clear_jerk_weight();
  static const int kJerkWeightFieldNumber = 2;
  double jerk_weight() const;
  void set_jerk_weight(double value);

  // optional double kappa_penalty_weight = 3 [default = 1000];
  bool has_kappa_penalty_weight() const;
  void clear_kappa_penalty_weight();
  static const int kKappaPenaltyWeightFieldNumber = 3;
  double kappa_penalty_weight() const;
  void set_kappa_penalty_weight(double value);

  // optional double ref_s_weight = 4 [default = 10];
  bool has_ref_s_weight() const;
  void clear_ref_s_weight();
  static const int kRefSWeightFieldNumber = 4;
  double ref_s_weight() const;
  void set_ref_s_weight(double value);

  // optional double ref_v_weight = 5 [default = 10];
  bool has_ref_v_weight() const;
  void clear_ref_v_weight();
  static const int kRefVWeightFieldNumber = 5;
  double ref_v_weight() const;
  void set_ref_v_weight(double value);

  // @@protoc_insertion_point(class_scope:planing.PiecewiseJerkSpeedOptimizerConfig)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double acc_weight_;
  double jerk_weight_;
  double kappa_penalty_weight_;
  double ref_s_weight_;
  double ref_v_weight_;
  friend struct ::TableStruct_planer_5fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PlannerOpenSpaceConfig

// optional .planing.WarmStartConfig warm_start_config = 2;
inline bool PlannerOpenSpaceConfig::has_warm_start_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlannerOpenSpaceConfig::clear_warm_start_config() {
  if (warm_start_config_ != nullptr) warm_start_config_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::planing::WarmStartConfig& PlannerOpenSpaceConfig::warm_start_config() const {
  const ::planing::WarmStartConfig* p = warm_start_config_;
  // @@protoc_insertion_point(field_get:planing.PlannerOpenSpaceConfig.warm_start_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::planing::WarmStartConfig*>(
      &::planing::_WarmStartConfig_default_instance_);
}
inline ::planing::WarmStartConfig* PlannerOpenSpaceConfig::release_warm_start_config() {
  // @@protoc_insertion_point(field_release:planing.PlannerOpenSpaceConfig.warm_start_config)
  _has_bits_[0] &= ~0x00000001u;
  ::planing::WarmStartConfig* temp = warm_start_config_;
  warm_start_config_ = nullptr;
  return temp;
}
inline ::planing::WarmStartConfig* PlannerOpenSpaceConfig::mutable_warm_start_config() {
  _has_bits_[0] |= 0x00000001u;
  if (warm_start_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::planing::WarmStartConfig>(GetArenaNoVirtual());
    warm_start_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planing.PlannerOpenSpaceConfig.warm_start_config)
  return warm_start_config_;
}
inline void PlannerOpenSpaceConfig::set_allocated_warm_start_config(::planing::WarmStartConfig* warm_start_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete warm_start_config_;
  }
  if (warm_start_config) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      warm_start_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, warm_start_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  warm_start_config_ = warm_start_config;
  // @@protoc_insertion_point(field_set_allocated:planing.PlannerOpenSpaceConfig.warm_start_config)
}

// optional float delta_t = 7 [default = 1];
inline bool PlannerOpenSpaceConfig::has_delta_t() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlannerOpenSpaceConfig::clear_delta_t() {
  delta_t_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline float PlannerOpenSpaceConfig::delta_t() const {
  // @@protoc_insertion_point(field_get:planing.PlannerOpenSpaceConfig.delta_t)
  return delta_t_;
}
inline void PlannerOpenSpaceConfig::set_delta_t(float value) {
  _has_bits_[0] |= 0x00000008u;
  delta_t_ = value;
  // @@protoc_insertion_point(field_set:planing.PlannerOpenSpaceConfig.delta_t)
}

// optional double is_near_destination_threshold = 8 [default = 0.001];
inline bool PlannerOpenSpaceConfig::has_is_near_destination_threshold() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlannerOpenSpaceConfig::clear_is_near_destination_threshold() {
  is_near_destination_threshold_ = 0.001;
  _has_bits_[0] &= ~0x00000010u;
}
inline double PlannerOpenSpaceConfig::is_near_destination_threshold() const {
  // @@protoc_insertion_point(field_get:planing.PlannerOpenSpaceConfig.is_near_destination_threshold)
  return is_near_destination_threshold_;
}
inline void PlannerOpenSpaceConfig::set_is_near_destination_threshold(double value) {
  _has_bits_[0] |= 0x00000010u;
  is_near_destination_threshold_ = value;
  // @@protoc_insertion_point(field_set:planing.PlannerOpenSpaceConfig.is_near_destination_threshold)
}

// optional bool enable_check_parallel_trajectory = 9 [default = false];
inline bool PlannerOpenSpaceConfig::has_enable_check_parallel_trajectory() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlannerOpenSpaceConfig::clear_enable_check_parallel_trajectory() {
  enable_check_parallel_trajectory_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool PlannerOpenSpaceConfig::enable_check_parallel_trajectory() const {
  // @@protoc_insertion_point(field_get:planing.PlannerOpenSpaceConfig.enable_check_parallel_trajectory)
  return enable_check_parallel_trajectory_;
}
inline void PlannerOpenSpaceConfig::set_enable_check_parallel_trajectory(bool value) {
  _has_bits_[0] |= 0x00000002u;
  enable_check_parallel_trajectory_ = value;
  // @@protoc_insertion_point(field_set:planing.PlannerOpenSpaceConfig.enable_check_parallel_trajectory)
}

// optional bool enable_linear_interpolation = 10 [default = false];
inline bool PlannerOpenSpaceConfig::has_enable_linear_interpolation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlannerOpenSpaceConfig::clear_enable_linear_interpolation() {
  enable_linear_interpolation_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool PlannerOpenSpaceConfig::enable_linear_interpolation() const {
  // @@protoc_insertion_point(field_get:planing.PlannerOpenSpaceConfig.enable_linear_interpolation)
  return enable_linear_interpolation_;
}
inline void PlannerOpenSpaceConfig::set_enable_linear_interpolation(bool value) {
  _has_bits_[0] |= 0x00000004u;
  enable_linear_interpolation_ = value;
  // @@protoc_insertion_point(field_set:planing.PlannerOpenSpaceConfig.enable_linear_interpolation)
}

// optional double is_near_destination_theta_threshold = 11 [default = 0.05];
inline bool PlannerOpenSpaceConfig::has_is_near_destination_theta_threshold() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlannerOpenSpaceConfig::clear_is_near_destination_theta_threshold() {
  is_near_destination_theta_threshold_ = 0.05;
  _has_bits_[0] &= ~0x00000020u;
}
inline double PlannerOpenSpaceConfig::is_near_destination_theta_threshold() const {
  // @@protoc_insertion_point(field_get:planing.PlannerOpenSpaceConfig.is_near_destination_theta_threshold)
  return is_near_destination_theta_threshold_;
}
inline void PlannerOpenSpaceConfig::set_is_near_destination_theta_threshold(double value) {
  _has_bits_[0] |= 0x00000020u;
  is_near_destination_theta_threshold_ = value;
  // @@protoc_insertion_point(field_set:planing.PlannerOpenSpaceConfig.is_near_destination_theta_threshold)
}

// -------------------------------------------------------------------

// WarmStartConfig

// optional double xy_grid_resolution = 1 [default = 0.1];
inline bool WarmStartConfig::has_xy_grid_resolution() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WarmStartConfig::clear_xy_grid_resolution() {
  xy_grid_resolution_ = 0.1;
  _has_bits_[0] &= ~0x00000010u;
}
inline double WarmStartConfig::xy_grid_resolution() const {
  // @@protoc_insertion_point(field_get:planing.WarmStartConfig.xy_grid_resolution)
  return xy_grid_resolution_;
}
inline void WarmStartConfig::set_xy_grid_resolution(double value) {
  _has_bits_[0] |= 0x00000010u;
  xy_grid_resolution_ = value;
  // @@protoc_insertion_point(field_set:planing.WarmStartConfig.xy_grid_resolution)
}

// optional double phi_grid_resolution = 2 [default = 0.005];
inline bool WarmStartConfig::has_phi_grid_resolution() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WarmStartConfig::clear_phi_grid_resolution() {
  phi_grid_resolution_ = 0.005;
  _has_bits_[0] &= ~0x00000020u;
}
inline double WarmStartConfig::phi_grid_resolution() const {
  // @@protoc_insertion_point(field_get:planing.WarmStartConfig.phi_grid_resolution)
  return phi_grid_resolution_;
}
inline void WarmStartConfig::set_phi_grid_resolution(double value) {
  _has_bits_[0] |= 0x00000020u;
  phi_grid_resolution_ = value;
  // @@protoc_insertion_point(field_set:planing.WarmStartConfig.phi_grid_resolution)
}

// optional uint64 next_node_num = 3 [default = 10];
inline bool WarmStartConfig::has_next_node_num() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WarmStartConfig::clear_next_node_num() {
  next_node_num_ = PROTOBUF_ULONGLONG(10);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint64 WarmStartConfig::next_node_num() const {
  // @@protoc_insertion_point(field_get:planing.WarmStartConfig.next_node_num)
  return next_node_num_;
}
inline void WarmStartConfig::set_next_node_num(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  next_node_num_ = value;
  // @@protoc_insertion_point(field_set:planing.WarmStartConfig.next_node_num)
}

// optional double step_size = 4 [default = 0.05];
inline bool WarmStartConfig::has_step_size() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void WarmStartConfig::clear_step_size() {
  step_size_ = 0.05;
  _has_bits_[0] &= ~0x00000080u;
}
inline double WarmStartConfig::step_size() const {
  // @@protoc_insertion_point(field_get:planing.WarmStartConfig.step_size)
  return step_size_;
}
inline void WarmStartConfig::set_step_size(double value) {
  _has_bits_[0] |= 0x00000080u;
  step_size_ = value;
  // @@protoc_insertion_point(field_set:planing.WarmStartConfig.step_size)
}

// optional double traj_forward_penalty = 5 [default = 0];
inline bool WarmStartConfig::has_traj_forward_penalty() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WarmStartConfig::clear_traj_forward_penalty() {
  traj_forward_penalty_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double WarmStartConfig::traj_forward_penalty() const {
  // @@protoc_insertion_point(field_get:planing.WarmStartConfig.traj_forward_penalty)
  return traj_forward_penalty_;
}
inline void WarmStartConfig::set_traj_forward_penalty(double value) {
  _has_bits_[0] |= 0x00000002u;
  traj_forward_penalty_ = value;
  // @@protoc_insertion_point(field_set:planing.WarmStartConfig.traj_forward_penalty)
}

// optional double traj_back_penalty = 6 [default = 0];
inline bool WarmStartConfig::has_traj_back_penalty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WarmStartConfig::clear_traj_back_penalty() {
  traj_back_penalty_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double WarmStartConfig::traj_back_penalty() const {
  // @@protoc_insertion_point(field_get:planing.WarmStartConfig.traj_back_penalty)
  return traj_back_penalty_;
}
inline void WarmStartConfig::set_traj_back_penalty(double value) {
  _has_bits_[0] |= 0x00000004u;
  traj_back_penalty_ = value;
  // @@protoc_insertion_point(field_set:planing.WarmStartConfig.traj_back_penalty)
}

// optional double traj_gear_switch_penalty = 7 [default = 0];
inline bool WarmStartConfig::has_traj_gear_switch_penalty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WarmStartConfig::clear_traj_gear_switch_penalty() {
  traj_gear_switch_penalty_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double WarmStartConfig::traj_gear_switch_penalty() const {
  // @@protoc_insertion_point(field_get:planing.WarmStartConfig.traj_gear_switch_penalty)
  return traj_gear_switch_penalty_;
}
inline void WarmStartConfig::set_traj_gear_switch_penalty(double value) {
  _has_bits_[0] |= 0x00000008u;
  traj_gear_switch_penalty_ = value;
  // @@protoc_insertion_point(field_set:planing.WarmStartConfig.traj_gear_switch_penalty)
}

// optional double traj_steer_penalty = 8 [default = 50];
inline bool WarmStartConfig::has_traj_steer_penalty() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void WarmStartConfig::clear_traj_steer_penalty() {
  traj_steer_penalty_ = 50;
  _has_bits_[0] &= ~0x00000100u;
}
inline double WarmStartConfig::traj_steer_penalty() const {
  // @@protoc_insertion_point(field_get:planing.WarmStartConfig.traj_steer_penalty)
  return traj_steer_penalty_;
}
inline void WarmStartConfig::set_traj_steer_penalty(double value) {
  _has_bits_[0] |= 0x00000100u;
  traj_steer_penalty_ = value;
  // @@protoc_insertion_point(field_set:planing.WarmStartConfig.traj_steer_penalty)
}

// optional double traj_steer_change_penalty = 9 [default = 25];
inline bool WarmStartConfig::has_traj_steer_change_penalty() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void WarmStartConfig::clear_traj_steer_change_penalty() {
  traj_steer_change_penalty_ = 25;
  _has_bits_[0] &= ~0x00000200u;
}
inline double WarmStartConfig::traj_steer_change_penalty() const {
  // @@protoc_insertion_point(field_get:planing.WarmStartConfig.traj_steer_change_penalty)
  return traj_steer_change_penalty_;
}
inline void WarmStartConfig::set_traj_steer_change_penalty(double value) {
  _has_bits_[0] |= 0x00000200u;
  traj_steer_change_penalty_ = value;
  // @@protoc_insertion_point(field_set:planing.WarmStartConfig.traj_steer_change_penalty)
}

// optional double grid_a_star_xy_resolution = 15 [default = 0.1];
inline bool WarmStartConfig::has_grid_a_star_xy_resolution() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void WarmStartConfig::clear_grid_a_star_xy_resolution() {
  grid_a_star_xy_resolution_ = 0.1;
  _has_bits_[0] &= ~0x00000400u;
}
inline double WarmStartConfig::grid_a_star_xy_resolution() const {
  // @@protoc_insertion_point(field_get:planing.WarmStartConfig.grid_a_star_xy_resolution)
  return grid_a_star_xy_resolution_;
}
inline void WarmStartConfig::set_grid_a_star_xy_resolution(double value) {
  _has_bits_[0] |= 0x00000400u;
  grid_a_star_xy_resolution_ = value;
  // @@protoc_insertion_point(field_set:planing.WarmStartConfig.grid_a_star_xy_resolution)
}

// optional double node_radius = 16 [default = 0.5];
inline bool WarmStartConfig::has_node_radius() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void WarmStartConfig::clear_node_radius() {
  node_radius_ = 0.5;
  _has_bits_[0] &= ~0x00000800u;
}
inline double WarmStartConfig::node_radius() const {
  // @@protoc_insertion_point(field_get:planing.WarmStartConfig.node_radius)
  return node_radius_;
}
inline void WarmStartConfig::set_node_radius(double value) {
  _has_bits_[0] |= 0x00000800u;
  node_radius_ = value;
  // @@protoc_insertion_point(field_set:planing.WarmStartConfig.node_radius)
}

// optional .planing.PiecewiseJerkSpeedOptimizerConfig s_curve_config = 17;
inline bool WarmStartConfig::has_s_curve_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WarmStartConfig::clear_s_curve_config() {
  if (s_curve_config_ != nullptr) s_curve_config_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::planing::PiecewiseJerkSpeedOptimizerConfig& WarmStartConfig::s_curve_config() const {
  const ::planing::PiecewiseJerkSpeedOptimizerConfig* p = s_curve_config_;
  // @@protoc_insertion_point(field_get:planing.WarmStartConfig.s_curve_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::planing::PiecewiseJerkSpeedOptimizerConfig*>(
      &::planing::_PiecewiseJerkSpeedOptimizerConfig_default_instance_);
}
inline ::planing::PiecewiseJerkSpeedOptimizerConfig* WarmStartConfig::release_s_curve_config() {
  // @@protoc_insertion_point(field_release:planing.WarmStartConfig.s_curve_config)
  _has_bits_[0] &= ~0x00000001u;
  ::planing::PiecewiseJerkSpeedOptimizerConfig* temp = s_curve_config_;
  s_curve_config_ = nullptr;
  return temp;
}
inline ::planing::PiecewiseJerkSpeedOptimizerConfig* WarmStartConfig::mutable_s_curve_config() {
  _has_bits_[0] |= 0x00000001u;
  if (s_curve_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::planing::PiecewiseJerkSpeedOptimizerConfig>(GetArenaNoVirtual());
    s_curve_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planing.WarmStartConfig.s_curve_config)
  return s_curve_config_;
}
inline void WarmStartConfig::set_allocated_s_curve_config(::planing::PiecewiseJerkSpeedOptimizerConfig* s_curve_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete s_curve_config_;
  }
  if (s_curve_config) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      s_curve_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, s_curve_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  s_curve_config_ = s_curve_config;
  // @@protoc_insertion_point(field_set_allocated:planing.WarmStartConfig.s_curve_config)
}

// -------------------------------------------------------------------

// PiecewiseJerkSpeedOptimizerConfig

// optional double acc_weight = 1 [default = 1];
inline bool PiecewiseJerkSpeedOptimizerConfig::has_acc_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PiecewiseJerkSpeedOptimizerConfig::clear_acc_weight() {
  acc_weight_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline double PiecewiseJerkSpeedOptimizerConfig::acc_weight() const {
  // @@protoc_insertion_point(field_get:planing.PiecewiseJerkSpeedOptimizerConfig.acc_weight)
  return acc_weight_;
}
inline void PiecewiseJerkSpeedOptimizerConfig::set_acc_weight(double value) {
  _has_bits_[0] |= 0x00000001u;
  acc_weight_ = value;
  // @@protoc_insertion_point(field_set:planing.PiecewiseJerkSpeedOptimizerConfig.acc_weight)
}

// optional double jerk_weight = 2 [default = 10];
inline bool PiecewiseJerkSpeedOptimizerConfig::has_jerk_weight() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PiecewiseJerkSpeedOptimizerConfig::clear_jerk_weight() {
  jerk_weight_ = 10;
  _has_bits_[0] &= ~0x00000002u;
}
inline double PiecewiseJerkSpeedOptimizerConfig::jerk_weight() const {
  // @@protoc_insertion_point(field_get:planing.PiecewiseJerkSpeedOptimizerConfig.jerk_weight)
  return jerk_weight_;
}
inline void PiecewiseJerkSpeedOptimizerConfig::set_jerk_weight(double value) {
  _has_bits_[0] |= 0x00000002u;
  jerk_weight_ = value;
  // @@protoc_insertion_point(field_set:planing.PiecewiseJerkSpeedOptimizerConfig.jerk_weight)
}

// optional double kappa_penalty_weight = 3 [default = 1000];
inline bool PiecewiseJerkSpeedOptimizerConfig::has_kappa_penalty_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PiecewiseJerkSpeedOptimizerConfig::clear_kappa_penalty_weight() {
  kappa_penalty_weight_ = 1000;
  _has_bits_[0] &= ~0x00000004u;
}
inline double PiecewiseJerkSpeedOptimizerConfig::kappa_penalty_weight() const {
  // @@protoc_insertion_point(field_get:planing.PiecewiseJerkSpeedOptimizerConfig.kappa_penalty_weight)
  return kappa_penalty_weight_;
}
inline void PiecewiseJerkSpeedOptimizerConfig::set_kappa_penalty_weight(double value) {
  _has_bits_[0] |= 0x00000004u;
  kappa_penalty_weight_ = value;
  // @@protoc_insertion_point(field_set:planing.PiecewiseJerkSpeedOptimizerConfig.kappa_penalty_weight)
}

// optional double ref_s_weight = 4 [default = 10];
inline bool PiecewiseJerkSpeedOptimizerConfig::has_ref_s_weight() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PiecewiseJerkSpeedOptimizerConfig::clear_ref_s_weight() {
  ref_s_weight_ = 10;
  _has_bits_[0] &= ~0x00000008u;
}
inline double PiecewiseJerkSpeedOptimizerConfig::ref_s_weight() const {
  // @@protoc_insertion_point(field_get:planing.PiecewiseJerkSpeedOptimizerConfig.ref_s_weight)
  return ref_s_weight_;
}
inline void PiecewiseJerkSpeedOptimizerConfig::set_ref_s_weight(double value) {
  _has_bits_[0] |= 0x00000008u;
  ref_s_weight_ = value;
  // @@protoc_insertion_point(field_set:planing.PiecewiseJerkSpeedOptimizerConfig.ref_s_weight)
}

// optional double ref_v_weight = 5 [default = 10];
inline bool PiecewiseJerkSpeedOptimizerConfig::has_ref_v_weight() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PiecewiseJerkSpeedOptimizerConfig::clear_ref_v_weight() {
  ref_v_weight_ = 10;
  _has_bits_[0] &= ~0x00000010u;
}
inline double PiecewiseJerkSpeedOptimizerConfig::ref_v_weight() const {
  // @@protoc_insertion_point(field_get:planing.PiecewiseJerkSpeedOptimizerConfig.ref_v_weight)
  return ref_v_weight_;
}
inline void PiecewiseJerkSpeedOptimizerConfig::set_ref_v_weight(double value) {
  _has_bits_[0] |= 0x00000010u;
  ref_v_weight_ = value;
  // @@protoc_insertion_point(field_set:planing.PiecewiseJerkSpeedOptimizerConfig.ref_v_weight)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planing

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_planer_5fconfig_2eproto
